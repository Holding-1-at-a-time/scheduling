import { render, screen, fireEvent } from '@testing-library/react';
import AppointmentScheduler from 'path/to/AppointmentScheduler'; // Adjust path as needed
// Generated by CodiumAI
// Generated by CodiumAI
  afterEach(() => {
    jest.restoreAllMocks();
    cleanup();
  });

  beforeEach(() => {
    jest.spyOn(api.appointments, 'getAppointments').mockResolvedValueOnce(mockAppointments);
  });

  it('should handle error when creating an appointment', async () => {
    const mockError = new Error('Appointment creation failed');
    jest.spyOn(api.appointments, 'createAppointment').mockRejectedValueOnce(mockError);

    render(<AppointmentScheduler />);

    fireEvent.click(screen.getByText('Create Appointment'));

    await waitFor(() => {
      expect(screen.getByText('Error creating appointment: Appointment creation failed')).toBeInTheDocument();
    });
  });
    // Handles errors when updating an appointment
    it('should handle errors when updating an appointment', async () => {
      const mockError = new Error('Update error');
      const mockAppointment = { _id: '123', status: 'Scheduled' };
      updateAppointment.mockRejectedValueOnce(mockError);

      await expect(handleAppointmentUpdate(mockAppointment)).rejects.toThrowError('Error updating appointment: Update error');
      expect(console.error).toHaveBeenCalledWith('Error updating appointment:', mockError);
    });

    // Handles errors when cancelling an appointment
    it('should handle error when cancelling an appointment', async () => {
      const mockError = new Error('Cancellation failed');
      cancelAppointment.mockRejectedValue(mockError);

      render(<AppointmentScheduler />);

      const appointment = { _id: '123' };
      await act(async () => {
        fireEvent.click(screen.getByText('Cancel'));
      });

      expect(console.error).toHaveBeenCalledWith('Error cancelling appointment:', mockError);
    });
      // Custom error boundary to capture error messages
      const ErrorBoundary = ({ children }) => {
        return <ErrorBoundary fallbackRender={({ error }) => <div>{error.message}</div>}>{children}</ErrorBoundary>;
      };

      // Select an invalid date by passing a string instead of a Date object
      userEvent.type(getByRole('textbox'), 'invalid date');

      // Check if the error message is displayed
      expect(screen.getByText('Invalid date selected')).toBeInTheDocument();
    // Allows creating a new appointment with default values
    it('should create a new appointment with default values', async () => {
      const mockCreateAppointment = jest.fn();
      const mockFormat = jest.spyOn(dateFns, 'format').mockReturnValue('2023-01-15');
      const mockSelectedDate = new Date('2023-01-15');

      render(<AppointmentScheduler createAppointment={mockCreateAppointment} />);

      await act(async () => {
        userEvent.click(screen.getByText('Create Appointment'));
      });

      expect(mockCreateAppointment).toHaveBeenCalledWith({
        date: '2023-01-15',
        time: '10:00 AM',
        service: 'Full Detail',
        status: 'Scheduled',
      });

      mockFormat.mockRestore();
      cleanup();
    });

    // Allows updating an appointment status to "Completed"
    it('should update appointment status to "Completed" when handleAppointmentUpdate is called', async () => {
      const appointment = { _id: '123' };
      const updateAppointmentMock = jest.fn();
      updateAppointmentMock.mockResolvedValueOnce();
      const handleAppointmentUpdate = jest.fn(); // Mocking handleAppointmentUpdate

      const { getByText } = render(<AppointmentScheduler />);
      await act(async () => {
        await fireEvent.click(getByText('Create Appointment'));
      });

      await act(async () => {
        await handleAppointmentUpdate(appointment);
      });

      expect(updateAppointmentMock).toHaveBeenCalledWith({ id: '123', status: 'Completed' });
    });
      await act(async () {
        userEvent.click(screen.getByText('Create Appointment'));
      });

      await act(async () {
        userEvent.click(screen.getByRole('button', { name: 'Cancel' }));
      });
    // Sorts appointments by time in ascending order
    it('should sort appointments by time in ascending order', () => {
      const mockAppointments = [
        { _id: '1', time: '2023-09-15T10:00:00.000Z' },
        { _id: '2', time: '2023-09-15T11:00:00.000Z' },
        { _id: '3', time: '2023-09-15T09:00:00.000Z' },
      ];
      const mockUseQuery = jest.fn(() => mockAppointments);
      jest.mock('convex/react', () => ({
        useQuery: mockUseQuery,
      }));

      render(<AppointmentScheduler />);

      const sortedAppointments = screen.getAllByRole('row').map(row => ({
        time: row.children[0].textContent,
      }));

      const expectedSortedAppointments = [
        { time: '9:00 AM' },
        { time: '10:00 AM' },
        { time: '11:00 AM' },
      ];

      expect(sortedAppointments).toEqual(expectedSortedAppointments);
    });

    // Displays the correct status badge for each appointment
    it('should display correct status badge for each appointment', () => {
      // Mocked data for appointments
      const mockAppointments = [
        { _id: 1, time: '10:00 AM', service: 'Full Detail', status: 'Scheduled' },
        { _id: 2, time: '11:00 AM', service: 'Oil Change', status: 'Completed' },
      ];

      // Mock the sortedAppointments returned by useMemo
      jest.spyOn(React, 'useMemo').mockReturnValue(mockAppointments);

      // Render the AppointmentScheduler component
      const { getAllByTestId } = render(<AppointmentScheduler />);

      // Check if the correct status badges are displayed for each appointment
      const statusBadges = getAllByTestId('status-badge');
      expect(statusBadges).toHaveLength(2);
      expect(statusBadges[0]).toHaveTextContent('Scheduled');
      expect(statusBadges[1]).toHaveTextContent('Completed');
    });

    // Shows a confirmation message or feedback after creating, updating, or cancelling an appointment
    it('should show confirmation message after creating an appointment', async () => {
      const mockCreateAppointment = jest.fn();
      const mockConsoleError = jest.spyOn(console, 'error').mockImplementation();
  
      mockCreateAppointment.mockResolvedValueOnce();
  
      render(<AppointmentScheduler />);
  
      await act(async () => {
        fireEvent.click(screen.getByText('Create Appointment'));
      });
  
      expect(mockCreateAppointment).toHaveBeenCalled();
      expect(mockConsoleError).not.toHaveBeenCalled();
  
      mockConsoleError.mockRestore();
    });

    // Tests the performance impact of sorting a large number of appointments
    it('should test performance impact of sorting appointments', () => {
        // Mock a large number of appointments
        const mockAppointments = Array.from({ length: 1000 }, (_, index) => ({
            time: new Date(2023, 0, index + 1).toISOString(),
        }));
    
        // Mock the useQuery hook to return the mock appointments
        jest.spyOn(convex, 'useQuery').mockReturnValue(mockAppointments);
    
        // Render the AppointmentScheduler component
    
        // Assert the performance impact of sorting appointments
    });

    // Verifies the UI responsiveness on different screen sizes
    it('should verify UI responsiveness on different screen sizes', async () => {

        // Render the AppointmentScheduler component
        render(<AppointmentScheduler />);

        fireEvent(window, new Event('resize'));

        // Assert the UI responsiveness
        expect(screen.getByRole('textbox')).toBeInTheDocument();
        expect(screen.getByText('Invalid date selected')).toBeInTheDocument();
    });

describe('AppointmentScheduler', () => {

    // Renders the AppointmentScheduler component without crashing
    it('should render AppointmentScheduler component without crashing', () => {
      const { getByText } = render(<AppointmentScheduler />);
      expect(getByText('Appointments')).toBeInTheDocument();
    });

    // Handles the case when there are no appointments for the selected date
    it('should display no appointments message when there are no appointments for the selected date', () => {
      useQuery.mockReturnValue([]);
      const { getByText } = render(<AppointmentScheduler />);
      expect(getByText('Showing appointments for')).toBeInTheDocument();
      expect(getByText('No appointments found')).toBeInTheDocument();
    });

/    // Handles errors when fetching appointments
    it('should handle errors when fetching appointments', async () => {
      const mockError = new Error('Failed to fetch appointments');
      jest.spyOn(api.appointments, 'getAppointments').mockRejectedValue(mockError);
      render(<AppointmentScheduler />);

      await waitFor(() => {
        expect(console.error).toHaveBeenCalledWith('Error fetching appointments:', mockError);
      });
    });

    // Handles errors when creating an appointment
    it('should handle error when creating an appointment', async () => {
      const mockError = new Error('Appointment creation failed');
      createAppointment.mockRejectedValue(mockError);

      render(<AppointmentScheduler />);

      fireEvent.click(screen.getByText('Create Appointment'));

      await waitFor(() => {
        expect(console.error).toHaveBeenCalledWith('Error creating appointment:', mockError);
      });
    });

    // Handles errors when updating an appointment
    it('should handle errors when updating an appointment', async () => {
      const mockError = new Error('Update error');
      const mockAppointment = { _id: '123', status: 'Scheduled' };
      updateAppointment.mockRejectedValueOnce(mockError);

      await expect(handleAppointmentUpdate(mockAppointment)).rejects.toThrowError('Error updating appointment: Update error');
      expect(console.error).toHaveBeenCalledWith('Error updating appointment:', mockError);
    });

    // Handles errors when cancelling an appointment
    it('should handle error when cancelling an appointment', async () => {
      const mockError = new Error('Cancellation failed');
      cancelAppointment.mockRejectedValue(mockError);

      render(<AppointmentScheduler />);

      const appointment = { _id: '123' };
      await act(async () => {
        fireEvent.click(screen.getByText('Cancel'));
      });

      expect(console.error).toHaveBeenCalledWith('Error cancelling appointment:', mockError);
    });

    // Handles invalid date selection in the calendar
    it('should display error message when an invalid date is selected', () => {
      const { getByText, getByRole } = render(<AppointmentScheduler />);
  
      // Mock console.error to capture the error message
      const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});
  
      // Select an invalid date by passing a string instead of a Date object
      fireEvent.change(getByRole('textbox'), { target: { value: 'invalid date' } });
  
      // Check if the error message is displayed
      expect(consoleError).toHaveBeenCalledWith(expect.stringContaining('Invalid date selected'));
  
      // Clean up
      consoleError.mockRestore();
    });

    // Handles appointments with missing or malformed data
    it('should handle missing or malformed data when creating an appointment', async () => {
      const createAppointmentMock = jest.fn();
      const { getByText } = render(<AppointmentScheduler />);
  
      // Mock the createAppointment function to throw an error
      createAppointmentMock.mockImplementationOnce(() => {
        throw new Error('Missing or malformed data');
      });
  
      // Trigger the appointment creation
      fireEvent.click(getByText('Create Appointment'));
  
      // Wait for the error to be logged
      await waitFor(() => {
        expect(console.error).toHaveBeenCalledWith('Error creating appointment:', new Error('Missing or malformed data'));
      });
    });

    // Displays the current date in the calendar by default
    it('should display current date by default in the calendar', () => {
      render(<AppointmentScheduler />);
      const currentDate = new Date();
      const formattedDate = format(currentDate, 'MMMM d, yyyy');
      expect(screen.getByText(formattedDate)).toBeInTheDocument();
    });

    // Fetches and displays appointments for the selected date
    it('should fetch and display appointments for the selected date', () => {
      // Mock the useQuery hook to return appointments for testing
      const mockAppointments = [
        { _id: '1', time: '10:00 AM', service: 'Full Detail', status: 'Scheduled' },
        { _id: '2', time: '11:00 AM', service: 'Oil Change', status: 'Completed' },
      ];
      jest.mock('convex/react', () => ({
        useQuery: jest.fn(() => mockAppointments),
      }));

      // Render the AppointmentScheduler component
      const { getByText } = render(<AppointmentScheduler />);

      // Check if appointments are displayed correctly
      expect(getByText('10:00 AM')).toBeInTheDocument();
      expect(getByText('Full Detail')).toBeInTheDocument();
      expect(getByText('Scheduled')).toBeInTheDocument();
      expect(getByText('11:00 AM')).toBeInTheDocument();
      expect(getByText('Oil Change')).toBeInTheDocument();
      expect(getByText('Completed')).toBeInTheDocument();
    });

    // Allows creating a new appointment with default values
    it('should create a new appointment with default values', async () => {
      const mockCreateAppointment = jest.fn();
      const mockFormat = jest.spyOn(dateFns, 'format').mockReturnValue('2023-01-15');
      const mockSelectedDate = new Date('2023-01-15');
  
      render(<AppointmentScheduler />);
  
      await act(async () => {
        fireEvent.click(screen.getByText('Create Appointment'));
      });
  
      expect(mockCreateAppointment).toHaveBeenCalledWith({
        date: '2023-01-15',
        time: '10:00 AM',
        service: 'Full Detail',
        status: 'Scheduled',
      });
  
      mockFormat.mockRestore();
    });

    // Allows updating an appointment status to "Completed"
    it('should update appointment status to "Completed" when handleAppointmentUpdate is called', async () => {
      const appointment = { _id: '123' };
      const updateAppointmentMock = jest.fn();
      updateAppointmentMock.mockResolvedValueOnce();

      const { getByText } = render(<AppointmentScheduler />);
      await act(async () => {
        await fireEvent.click(getByText('Create Appointment'));
      });

      await act(async () => {
        await handleAppointmentUpdate(appointment);
      });

      expect(updateAppointmentMock).toHaveBeenCalledWith({ id: '123', status: 'Completed' });
    });

    // Allows cancelling an appointment
    it('should cancel an appointment successfully', async () => {
      const appointment = { _id: '123' };
      const cancelAppointmentMock = jest.fn();
      jest.spyOn(api.appointments, 'cancelAppointment').mockImplementation(cancelAppointmentMock);

      render(<AppointmentScheduler />);

      await act(async () => {
        fireEvent.click(screen.getByText('Create Appointment'));
      });

      await act(async () => {
        fireEvent.click(screen.getByText('Cancel', { selector: 'button' }));
      });

      expect(cancelAppointmentMock).toHaveBeenCalledWith({ id: '123' });
    });

    // Updates the displayed appointments when the date is changed
    it('should update displayed appointments when date changes', () => {
        // Mock the useQuery hook to return appointments for testing
        const mockAppointments = [
            { _id: 1, time: "10:00 AM", service: "Full Detail", status: "Scheduled" },
            { _id: 2, time: "11:00 AM", service: "Oil Change", status: "Scheduled" },
        ];
        jest.mock('convex/react', () => ({
            useQuery: jest.fn(() => mockAppointments),
        }));

        // Render the AppointmentScheduler component
        const { getByText } = render(<AppointmentScheduler />);

        // Change the date by interacting with the Calendar component
        fireEvent.change(getByTestId('calendar-input'), { target: { value: '2023-12-25' } });

        // Check if the appointments for the new date are displayed
        expect(getByText('10:00 AM')).toBeInTheDocument();
        expect(getByText('11:00 AM')).toBeInTheDocument();
    });

    // Sorts appointments by time in ascending order
    it('should sort appointments by time in ascending order', () => {
      const mockAppointments = [
        { _id: '1', time: '2023-09-15T10:00:00.000Z' },
        { _id: '2', time: '2023-09-15T11:00:00.000Z' },
        { _id: '3', time: '2023-09-15T09:00:00.000Z' },
      ];
      const mockUseQuery = jest.fn(() => mockAppointments);
      jest.mock('convex/react', () => ({
        useQuery: mockUseQuery,
      }));

      render(<AppointmentScheduler />);

      const sortedAppointments = screen.getAllByRole('row').map(row => ({
        time: row.children[0].textContent,
      }));

      const expectedSortedAppointments = [
        { time: '9:00 AM' },
        { time: '10:00 AM' },
        { time: '11:00 AM' },
      ];

      expect(sortedAppointments).toEqual(expectedSortedAppointments);
    });

    // Displays the correct status badge for each appointment
    it('should display correct status badge for each appointment', () => {
      // Mocked data for appointments
      const mockAppointments = [
        { _id: 1, time: '10:00 AM', service: 'Full Detail', status: 'Scheduled' },
        { _id: 2, time: '11:00 AM', service: 'Oil Change', status: 'Completed' },
      ];

      // Mock the sortedAppointments returned by useMemo
      jest.spyOn(React, 'useMemo').mockReturnValue(mockAppointments);

      // Render the AppointmentScheduler component
      const { getAllByTestId } = render(<AppointmentScheduler />);

      // Check if the correct status badges are displayed for each appointment
      const statusBadges = getAllByTestId('status-badge');
      expect(statusBadges).toHaveLength(2);
      expect(statusBadges[0]).toHaveTextContent('Scheduled');
      expect(statusBadges[1]).toHaveTextContent('Completed');
    });

    // Shows a confirmation message or feedback after creating, updating, or cancelling an appointment
    it('should show confirmation message after creating an appointment', async () => {
      const mockCreateAppointment = jest.fn();
      const mockConsoleError = jest.spyOn(console, 'error').mockImplementation();
  
      mockCreateAppointment.mockResolvedValueOnce();
  
      render(<AppointmentScheduler />);
  
      await act(async () => {
        fireEvent.click(screen.getByText('Create Appointment'));
      });
  
      expect(mockCreateAppointment).toHaveBeenCalled();
      expect(mockConsoleError).not.toHaveBeenCalled();
  
      mockConsoleError.mockRestore();
    });
});
